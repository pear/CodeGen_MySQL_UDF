<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE udf SYSTEM "udf_extension.dtd">
<udf name="regex">

  <maintainer>
    <name>Hartmut Holzgraefe</name>
    <email>hartmut@php.net</email>
  </maintainer>

  <license>PHP</license>

  <code role="header">
<![CDATA[

#if MYSQL_VERSION_ID < 50000
#error need MySQL >= 5.0
#endif

#include <sys/types.h>

// TODO: my_regex.h is not installed by "make install"
#include "/home/hartmut/projects/mysql/dev/5.0/regex/my_regex.h"

// helper function borrowed from PHP, slightly modified
static char *my_regex_replace(const char *pattern, const char *replace, const char *string)
{
    my_regex_t re;
    my_regmatch_t *subs;

    char *buf,  /* buf is where we build the replaced string */
         *nbuf, /* nbuf is used when we grow the buffer */
         *walkbuf; /* used to walk buf when replacing backrefs */
    const char *walk; /* used to walk replacement string for backrefs */
    int buf_len;
    int pos, tmp, string_len, new_l;
    int err, copts = REG_EXTENDED;

    string_len = strlen(string);

    err = my_regcomp(&re, pattern, copts, &my_charset_bin);
    if (err) {
        return NULL;
    }

    /* allocate storage for (sub-)expression-matches */
    subs = (my_regmatch_t *)calloc(sizeof(my_regmatch_t),re.re_nsub+1);

    /* start with a buffer that is twice the size of the stringo
       we're doing replacements in */
    buf_len = 2 * string_len + 1;
    buf = calloc(buf_len, sizeof(char));

    err = pos = 0;
    buf[0] = '\0';
    while (!err) {
        err = my_regexec(&re, &string[pos], re.re_nsub+1, subs, (pos ? REG_NOTBOL : 0));

        if (err && err != REG_NOMATCH) {
            free(subs);
            free(buf);
            my_regfree(&re);
            return NULL;
        }

        if (!err) {
            /* backref replacement is done in two passes:
               1) find out how long the string will be, and allocate buf
               2) copy the part before match, replacement and backrefs to buf

               Jaakko Hyvätti <Jaakko.Hyvatti@iki.fi>
               */

            new_l = strlen(buf) + subs[0].rm_so; /* part before the match */
            walk = replace;
            while (*walk) {
                if ('\\' == *walk && isdigit((unsigned char)walk[1]) && ((unsigned char)walk[1]) - '0' <= re.re_nsub) {
                    if (subs[walk[1] - '0'].rm_so > -1 && subs[walk[1] - '0'].rm_eo > -1) {
                        new_l += subs[walk[1] - '0'].rm_eo - subs[walk[1] - '0'].rm_so;
                    }    
                    walk += 2;
                } else {
                    new_l++;
                    walk++;
                }
            }
            if (new_l + 1 > buf_len) {
                buf_len = 1 + buf_len + 2 * new_l;
                nbuf = malloc(buf_len);
                strcpy(nbuf, buf);
                free(buf);
                buf = nbuf;
            }
            tmp = strlen(buf);
            /* copy the part of the string before the match */
            strncat(buf, &string[pos], subs[0].rm_so);

            /* copy replacement and backrefs */
            walkbuf = &buf[tmp + subs[0].rm_so];
            walk = replace;
            while (*walk) {
                if ('\\' == *walk && isdigit(walk[1]) && walk[1] - '0' <= (int)re.re_nsub) {
                    if (subs[walk[1] - '0'].rm_so > -1 && subs[walk[1] - '0'].rm_eo > -1
                        /* this next case shouldn't happen. it does. */
                        && subs[walk[1] - '0'].rm_so <= subs[walk[1] - '0'].rm_eo) {
                        
                        tmp = subs[walk[1] - '0'].rm_eo - subs[walk[1] - '0'].rm_so;
                        memcpy (walkbuf, &string[pos + subs[walk[1] - '0'].rm_so], tmp);
                        walkbuf += tmp;
                    }
                    walk += 2;
                } else {
                    *walkbuf++ = *walk++;
                }
            }
            *walkbuf = '\0';

            /* and get ready to keep looking for replacements */
            if (subs[0].rm_so == subs[0].rm_eo) {
                if (subs[0].rm_so + pos >= string_len) {
                    break;
                }
                new_l = strlen (buf) + 1;
                if (new_l + 1 > buf_len) {
                    buf_len = 1 + buf_len + 2 * new_l;
                    nbuf = calloc(buf_len, sizeof(char));
                    strcpy(nbuf, buf);
                    free(buf);
                    buf = nbuf;
                }
                pos += subs[0].rm_eo + 1;
                buf [new_l-1] = string [pos-1];
                buf [new_l] = '\0';
            } else {
                pos += subs[0].rm_eo;
            }
        } else { /* REG_NOMATCH */
            new_l = strlen(buf) + strlen(&string[pos]);
            if (new_l + 1 > buf_len) {
                buf_len = new_l + 1; /* now we know exactly how long it is */
                nbuf = calloc(buf_len, sizeof(char));
                strcpy(nbuf, buf);
                free(buf);
                buf = nbuf;
            }
            /* stick that last bit of string on our output */
            strcat(buf, &string[pos]);
        }
    }

    /* don't want to leak memory .. */
    free(subs);
    my_regfree(&re);

    /* whew. */
    return (buf);
}

static int parse_mode(const char *mode)
{
	int flags = REG_EXTENDED | REG_NEWLINE;

	fprintf(stderr, "mode is %s\n", mode);

	if (mode) {
  		do {
			switch (*mode++) {
				case 'i': flags |=  REG_ICASE;   break; /* case insensitive */
				case 'c': flags &= ~REG_ICASE;   break; /* case sensitive   */
				case 'n':  break; /* . matches newline */
				case 'm':  break; /* multiple lines    */
				case 'x':  break; /* ignore whitespace */
				default: break;
			}
		} while (*mode != '\0');
	}

	fprintf(stderr, "flags are %X\n", flags);

	return flags;
}


]]>  
  </code>


  <function name="regexp_like" returns="int" null="yes">
    <param name="text"    type="string"/>
    <param name="pattern" type="string"/>
    <param name="mode"    type="string" optional="yes"/>

    <data>
     <element name="expr"    type="my_regex_t"/>
     <element name="dynamic" type="int" />
    </data>               

    <init>
<?data
    if (pattern) {
        // static regex pattern -> we can compile it once and reuse it 
        int stat;
        char *copy;

        // we have to make sure we have a NUL terminated C string
        // as argument for my_regcomp           
        copy = strndup(pattern, pattern_len);
        stat  = my_regcomp(&data->expr, copy, parse_mode(mode), &my_charset_bin);
        free(copy);

        if (stat) {
            sprintf(message, "regcomp failed (error: %d)", stat);
            return 1; 
        }

        data->dynamic = 0;
    } else {
        data->dynamic = 1;
    }
?>
    </init>

    <deinit>
<?data
    if (!data->dynamic) {
        // free static compiler pattern
        my_regfree(&data->expr);
    }
?>
    </deinit>

    <code>
<?data
    my_regmatch_t match;
    int stat;
    char *copy;
    
    if (data->dynamic) {
        copy = strndup(pattern, pattern_len);
        stat  = my_regcomp(&data->expr, copy, parse_mode(mode), &my_charset_bin);
        free(copy);
        if (stat) {
            // TODO: need ERROR() and WARNING() macro
            RETURN_NULL;
        }
    }

    copy = strndup(text, text_len);
    stat = my_regexec(&data->expr, copy, 1, &match, 0);
    free(copy);

    if (data->dynamic) {
        my_regfree(&data->expr);
    }

    if (stat && (stat != REG_NOMATCH)) {
        fprintf(stderr, "regexec error %d '%s' '%s'\n", stat, pattern, text);
        RETURN_NULL;
    }

    RETURN_INT(stat == REG_NOMATCH ? 0 : 1);

?>
    </code>
  </function>


  <function name="regexp_substr" returns="string" null="yes">
    <param name="text"    type="string"/>
    <param name="pattern" type="string"/>

    <data>
     <element name="expr"    type="my_regex_t"/>
     <element name="dynamic" type="int" />
    </data>               

    <init>
<?data
    if (pattern) {
        // static regex pattern -> we can compile it once and reuse it 
        int stat;
        char *copy;

        // we have to make sure we have a NUL terminated C string
        // as argument for my_regcomp           
        copy = strndup(pattern, pattern_len);
        stat  = my_regcomp(&data->expr, copy, REG_EXTENDED, &my_charset_bin);
        free(copy);

        if (stat) {
            sprintf(message, "regcomp failed (error: %d)", stat);
            return 1; 
        }

        data->dynamic = 0;
    } else {
        data->dynamic = 1;
    }
?>
    </init>

    <deinit>
<?data
    if (!data->dynamic) {
        // free static compiler pattern
        my_regfree(&data->expr);
    }
?>
    </deinit>

    <code>
<?data
    my_regmatch_t match;
    int stat;
    char *copy;
    
    if (data->dynamic) {
        copy = strndup(pattern, pattern_len);
        stat  = my_regcomp(&data->expr, copy, REG_EXTENDED, &my_charset_bin);
        free(copy);
        if (stat) {
            // TODO: need ERROR() and WARNING() macro
            RETURN_NULL;
        }
    }

    copy = strndup(text, text_len);
    stat = my_regexec(&data->expr, copy, 1, &match, 0);
    free(copy);

    if (data->dynamic) {
        my_regfree(&data->expr);
    }

    if (stat) {
		if (stat != REG_NOMATCH) {
        	fprintf(stderr, "regexec error %d '%s' '%s'\n", stat, pattern, text);
		}
        RETURN_NULL;
    }

    RETURN_STRINGL(text + match.rm_so, match.rm_eo - match.rm_so);

?>
    </code>
  </function>


  <function name="regexp_instr" returns="int" null="yes">
    <param name="text"       type="string"/>
    <param name="pattern"    type="string"/>
    <param name="position"   type="int"    optional="yes" default="1"/>
    <param name="occurrence" type="int"    optional="yes" default="1"/>
    <param name="return_opt" type="int"    optional="yes" default="0"/>
    <param name="mode"       type="string" optional="yes" default="c"/>
    

    <data>
     <element name="expr"    type="my_regex_t"/>
     <element name="dynamic" type="int" />
    </data>               

    <init>
<?data
    if (pattern) {
        // static regex pattern -> we can compile it once and reuse it 
        int stat;
        char *copy;

        // we have to make sure we have a NUL terminated C string
        // as argument for my_regcomp           
        copy = strndup(pattern, pattern_len);
        stat  = my_regcomp(&data->expr, copy, parse_mode(mode), &my_charset_bin);
        free(copy);

        if (stat) {
            sprintf(message, "regcomp failed (error: %d)", stat);
            return 1; 
        }

        data->dynamic = 0;
    } else {
        data->dynamic = 1;
    }
?>
    </init>

    <deinit>
<?data
    if (!data->dynamic) {
        // free static compiler pattern
        my_regfree(&data->expr);
    }
?>
    </deinit>

    <code>
<?data
    my_regmatch_t match;
    int stat;
    char *copy;

	if (position) {
	  position -= 1; /* oracle offsets start at 1, not 0 */
	}
    
    if (data->dynamic) {
        copy = strndup(pattern, pattern_len);
        stat  = my_regcomp(&data->expr, copy, parse_mode(mode), &my_charset_bin);
        free(copy);
        if (stat) {
            // TODO: need ERROR() and WARNING() macro
            RETURN_NULL;
        }
    }

    copy = strndup(text, text_len);
	do {
	    stat = my_regexec(&data->expr, copy + position, 1, &match, 0);
		position += match.rm_so;
	} while ((stat == 0) && --occurrence >= 0);

    free(copy);

    if (data->dynamic) {
        my_regfree(&data->expr);
    }

    if (stat) {
        fprintf(stderr, "regexec error %d '%s' '%s'\n", stat, pattern, text);
        RETURN_NULL;
    }

    RETURN_INT(match.rm_so + return_opt ? 2 : 1);
?>
    </code>
  </function>


  <function name="regexp_replace" returns="string" null="yes">
    <param name="text"    type="string"/>
    <param name="pattern" type="string"/>
    <param name="replace" type="string"/>

    <code>
      char *c_pattern, *c_replace, *c_text;
      char *result;

      c_pattern = strndup(pattern, pattern_len);
      c_replace = strndup(replace, replace_len);
      c_text    = strndup(text,    text_len);

      result = my_regex_replace(c_pattern, c_replace, c_text);

      free(c_pattern);
      free(c_replace);
      free(c_text);

      if (result) {
        RETURN_STRING(result);
      } else {
        RETURN_NULL;
      }
    </code>

  </function>


</udf>