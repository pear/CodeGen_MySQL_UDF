<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>CodeGen_MySQL_UDF - the MySQL User Defined Functions code generator</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"></HEAD
><BODY
CLASS="book"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="AEN1"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="title"
><A
NAME="AEN1"
><TT
CLASS="literal"
>CodeGen_MySQL_UDF</TT
> - the MySQL User Defined Functions code generator</A
></H1
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1. <A
HREF="#AEN4"
>Introduction</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#AEN6"
>What is it?</A
></DT
><DT
>1.2. <A
HREF="#AEN14"
>Features</A
></DT
><DT
>1.3. <A
HREF="#AEN20"
>Installation</A
></DT
><DD
><DL
><DT
>1.3.1. <A
HREF="#AEN22"
>Online installation</A
></DT
><DT
>1.3.2. <A
HREF="#AEN25"
>Installing from package files</A
></DT
><DT
>1.3.3. <A
HREF="#AEN30"
>Installing from PEAR CVS</A
></DT
></DL
></DD
><DT
>1.4. <A
HREF="#AEN33"
>How to use it</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#AEN44"
>The XML description</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#AEN46"
>Basics</A
></DT
><DT
>2.2. <A
HREF="#AEN63"
>Release information</A
></DT
><DT
>2.3. <A
HREF="#AEN85"
>Functions</A
></DT
><DD
><DL
><DT
>2.3.1. <A
HREF="#AEN95"
>Return type</A
></DT
><DT
>2.3.2. <A
HREF="#AEN111"
>Parameters</A
></DT
><DT
>2.3.3. <A
HREF="#AEN138"
>Private data</A
></DT
><DT
>2.3.4. <A
HREF="#AEN152"
>Execution of regular functions</A
></DT
><DT
>2.3.5. <A
HREF="#AEN192"
>Execution of aggregate functions</A
></DT
></DL
></DD
><DT
>2.4. <A
HREF="#AEN203"
>Custom code</A
></DT
><DT
>2.5. <A
HREF="#AEN214"
>Dependencies</A
></DT
><DT
>2.6. <A
HREF="#AEN229"
>config.m4 fragments</A
></DT
><DT
>2.7. <A
HREF="#AEN236"
>Makefile fragments</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#AEN243"
>XML input parsing</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#AEN245"
>Includes</A
></DT
><DD
><DL
><DT
>3.1.1. <A
HREF="#AEN258"
>External entities</A
></DT
><DT
>3.1.2. <A
HREF="#AEN264"
>XInclude</A
></DT
><DT
>3.1.3. <A
HREF="#AEN282"
><TT
CLASS="literal"
>&#60;code&#62;</TT
> tags</A
></DT
></DL
></DD
><DT
>3.2. <A
HREF="#AEN292"
>Verbatim text data</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#AEN309"
>Usage</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="#AEN311"
>Invocation</A
></DT
><DT
>4.2. <A
HREF="#AEN321"
>Configuration</A
></DT
><DT
>4.3. <A
HREF="#AEN342"
>Compilation</A
></DT
><DT
>4.4. <A
HREF="#AEN347"
>Testing</A
></DT
><DT
>4.5. <A
HREF="#AEN351"
>Installation</A
></DT
></DL
></DD
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Examples</B
></DT
><DT
>2-1. <A
HREF="#AEN60"
>Extension basics</A
></DT
><DT
>2-2. <A
HREF="#AEN71"
>Release information</A
></DT
><DT
>2-3. <A
HREF="#AEN82"
>License</A
></DT
><DT
>2-4. <A
HREF="#AEN149"
>Accessing private data</A
></DT
><DT
>2-5. <A
HREF="#AEN200"
>A simple aggregate function</A
></DT
><DT
>2-6. <A
HREF="#AEN233"
>config.m4 additions</A
></DT
><DT
>2-7. <A
HREF="#AEN240"
>Makefile fragments</A
></DT
><DT
>3-1. <A
HREF="#AEN261"
>System Entities</A
></DT
><DT
>3-2. <A
HREF="#AEN270"
>XInclude</A
></DT
><DT
>3-3. <A
HREF="#AEN276"
>Verbatim XInclude</A
></DT
><DT
>3-4. <A
HREF="#AEN288"
>Using <TT
CLASS="literal"
>&#60;code src="..."&#62;</TT
></A
></DT
><DT
>3-5. <A
HREF="#AEN298"
>CDATA sections</A
></DT
><DT
>3-6. <A
HREF="#AEN305"
><TT
CLASS="literal"
>&#60;?data</TT
> processing instruction</A
></DT
></DL
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="AEN4"
></A
>Chapter 1. Introduction</H1
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN6"
>1.1. What is it?</A
></H2
><P
>&#13;    <TT
CLASS="literal"
>CodeGen_MySQL_UDF</TT
> is a tool that can automatically create 
    the basic framework for MySQL User Defined Functions (UDF) from a rather 
    simple XML specification file. The actual functionality is provided
    by the script <TT
CLASS="filename"
>udf-gen</TT
> that is installed by the
    <TT
CLASS="literal"
>CodeGen_MySQL_UDF</TT
> package.
   </P
><P
>&#13;    The code generated by <TT
CLASS="filename"
>udf-gen</TT
> is designed to work
    with MySQL versions 3.23, 4.0, 4.1 and 5.0 without modifications (although
    it is usually to compile it for a specific server version).
   </P
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN14"
>1.2. Features</A
></H2
><P
>&#13;    <TT
CLASS="literal"
>udf-gen</TT
> tries to support as many UDF writing aspects
    as possible. This currently includes code generation for simple and 
    aggregate functions and preparation of <TT
CLASS="filename"
>configure</TT
>
    and <TT
CLASS="filename"
>Makefile</TT
> related build files.
   </P
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN20"
>1.3. Installation</A
></H2
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="AEN22"
>1.3.1. Online installation</A
></H3
><P
>&#13;     The packages has not yet been accepted by PEAR (its in voting stage
     right now) so online installation is not yet possible.
    </P
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN25"
>1.3.2. Installing from package files</A
></H3
><P
>&#13;     A test package is available at
     <TT
CLASS="literal"
>http://hartmut.homeip.net/CodeGen-MySQL-UDF-0.9.0dev.tgz</TT
>.
     The package depends on <TT
CLASS="literal"
>CodeGen</TT
> so this needs to be
     available in your local PEAR installation before you can install the 
     test package.
    </P
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN30"
>1.3.3. Installing from PEAR CVS</A
></H3
><P
>&#13;     The package is not yet available from PEAR CVS as has not yet passed
     the proposal process.
    </P
></DIV
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN33"
>1.4. How to use it</A
></H2
><P
>&#13;    Given that you already have written your XML specs file invocing 
    <TT
CLASS="filename"
>udf-gen</TT
> is as simple as:
    <PRE
CLASS="screen"
>udf-gen specfile.xml</PRE
>
   </P
><P
>&#13;    <TT
CLASS="filename"
>udf-gen</TT
> will parse the specs file, create a new
    subdirectory and puts all generated files in there. The generated
    code is ready to be compiled using the usual
    <PRE
CLASS="screen"
>configure; make</PRE
>
    sequence.
   </P
><P
>&#13;    Below you find a hardcopy of <TT
CLASS="literal"
>udf-gen --help</TT
> output:
   </P
><PRE
CLASS="screen"
>&#13;
udf-gen 0.9.1dev,Copyright (c) 2003-2005 Hartmut Holzgraefe
Usage:

/usr/local/bin/udf-gen [-hxf] [-d dir] [--version] specfile.xml

  -h|--help          this message
  -x|--experimental  enable experimental features
  -d|--dir           output directory
  -f|--force         overwrite existing files/directories
  -l|--lint          check syntax only, don't create output
  --version          show version info

   </PRE
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="AEN44"
></A
>Chapter 2. The XML description</H1
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN46"
>2.1. Basics</A
></H2
><P
>&#13;    The top level container tag describing an extension is the
    <TT
CLASS="literal"
>&#60;extension&#62;</TT
> tag. The name of the extension
    is given in the <TT
CLASS="literal"
>name=...</TT
> attribute. The extension
    name has to be a valid file name as it is used the extensions
    directory name. 
   </P
><P
>&#13;	You can specify which CodeGen_MySQL_UDF version your specification file
    was build for using the <TT
CLASS="literal"
>version=...</TT
> attribute.
    The <TT
CLASS="filename"
>udf-gen</TT
> command will not accept specifications
    written for a newer version of CodeGen_MySQL_UDF than the one installed.
    If the requested version is older then the current one then <TT
CLASS="filename"
>udf-gen</TT
>
    will try to fall back to the older versions behavior for features
    that have changed in incompatible ways.
   </P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>&#13;     So far no such changes have happened.
    </P
></TD
></TR
></TABLE
></DIV
><P
>&#13;    The tags <TT
CLASS="literal"
>&#60;summary&#62;</TT
> and
    <TT
CLASS="literal"
>&#60;description&#62;</TT
> should be added at the very top of
    your extensions. The summary should be a short one-line
    description of the extension while the actually description can be
    as detailed as you like.
   </P
><DIV
CLASS="example"
><A
NAME="AEN60"
></A
><P
><B
>Example 2-1. Extension basics</B
></P
><PRE
CLASS="programlisting"
>&#13;
&#60;extension name="sample" version="0.9.0"&#62;
 &#60;summary&#62;A sample UDF extension&#60;/summary&#62;
 &#60;description&#62;
  This is a sample extension specification
  showing how to use CodeGen_MySQL_UDF for
  extension generation.
 &#60;/description&#62;
 ...

    </PRE
></DIV
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN63"
>2.2. Release information</A
></H2
><P
>&#13;    The release information for your UDF extension should include the
    extension authors and maintainers, the version number, state and
    release date, the chosen license and maybe a change log describing
    previous releases. 
   </P
><P
>&#13;    The <TT
CLASS="literal"
>&#60;maintainers&#62;</TT
>, <TT
CLASS="literal"
>&#60;release&#62;</TT
> and
    <TT
CLASS="literal"
>&#60;changelog&#62;</TT
> tags specifications are identical to  
    those in  the PEAR <TT
CLASS="literal"
>package.xml</TT
> specification so 
    please refer to the PEAR documentation here.
   </P
><DIV
CLASS="example"
><A
NAME="AEN71"
></A
><P
><B
>Example 2-2. Release information</B
></P
><PRE
CLASS="programlisting"
>&#13;
...
  &#60;maintainers&#62;
    &#60;maintainer&#62;
      &#60;user&#62;hholzgra&#60;/user&#62;
      &#60;name&#62;Hartmut Holzgraefe&#60;/name&#62;
      &#60;email&#62;hartmut@php.net&#60;/email&#62;
      &#60;role&#62;lead&#60;/role&#62;
    &#60;/maintainer&#62;
  &#60;/maintainers&#62;

  &#60;release&#62;
    &#60;version&#62;1.0&#60;/version&#62;
    &#60;date&#62;2002-07-09&#60;/date&#62;
    &#60;state&#62;stable&#60;/state&#62;
    &#60;notes&#62;
     The sample extension is now stable
    &#60;/notes&#62;
  &#60;/release&#62;

  &#60;changelog&#62;
    &#60;release&#62;
      &#60;version&#62;0.5&#60;/version&#62;
      &#60;date&#62;2002-07-05&#60;/date&#62;
      &#60;state&#62;beta&#60;/state&#62;
      &#60;notes&#62;First beta version&#60;/notes&#62;
    &#60;release&#62;
    &#60;release&#62;
      &#60;version&#62;0.1&#60;/version&#62;
      &#60;date&#62;2002-07-01&#60;/date&#62;
      &#60;state&#62;alpha&#60;/state&#62;
      &#60;notes&#62;First alpha version&#60;/notes&#62;
    &#60;release&#62;
  &#60;/changelog&#62;
...

    </PRE
></DIV
><P
>&#13;    The <TT
CLASS="literal"
>&#60;license&#62;</TT
> tag is a little more restrictive as
    its <TT
CLASS="literal"
>package.xml</TT
> counterpart as it is used to
    decide which license text should actually be written to the
    <TT
CLASS="literal"
>LICENSE</TT
>. For now you have to specify either
    <TT
CLASS="literal"
>GPL</TT
>, <TT
CLASS="literal"
>LGPL</TT
> or
    <TT
CLASS="literal"
>BSD</TT
>, any other value is taken as
    '<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>unknown</I
></SPAN
>'.
   </P
><DIV
CLASS="example"
><A
NAME="AEN82"
></A
><P
><B
>Example 2-3. License</B
></P
><PRE
CLASS="programlisting"
>&#13;
...
  &#60;license&#62;GPL&#60;/license&#62;
...

    </PRE
></DIV
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN85"
>2.3. Functions</A
></H2
><P
>&#13;    Two different kinds of functions may be defined using the
    <TT
CLASS="literal"
>&#60;function&#62;</TT
> tag: <TT
CLASS="literal"
>regular</TT
> 
    and <TT
CLASS="literal"
>aggregate</TT
> functions. The function type is 
    determined by the <TT
CLASS="literal"
>type=...</TT
> attribute and defaults 
    to <TT
CLASS="literal"
>regular</TT
>. 
   </P
><P
>&#13;    The function name is defined using the <TT
CLASS="literal"
>name=...</TT
> 
    attribute and has to be a valid C function name.  
   </P
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN95"
>2.3.1. Return type</A
></H3
><P
>&#13;     The return type of a function is defined using <TT
CLASS="literal"
>returns=...</TT
>,
     possible values are <TT
CLASS="literal"
>string</TT
> (default), <TT
CLASS="literal"
>int</TT
>,
     and <TT
CLASS="literal"
>real</TT
>. For a function 
     that may return <TT
CLASS="literal"
>NULL</TT
> values the <TT
CLASS="literal"
>null='yes'</TT
>
     attribute has to be set.
    </P
><P
>&#13;     The <TT
CLASS="literal"
>length=...</TT
> attribute can be used to define the
     max. length for a <TT
CLASS="literal"
>string</TT
> result or the number of 
     sigificant digits for <TT
CLASS="literal"
>int</TT
> and <TT
CLASS="literal"
>real</TT
>.
     For <TT
CLASS="literal"
>real</TT
> results the number of significant decimals
     can be defined using the <TT
CLASS="literal"
>decimal=...</TT
> attribute.
    </P
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN111"
>2.3.2. Parameters</A
></H3
><P
>&#13;     Function parameters are defined using the <TT
CLASS="literal"
>&#60;param&#62;</TT
>
     tag. The parameter name is defined by the <TT
CLASS="literal"
>name=...</TT
> attribute
     and has to be a valid C variable name. The parameter type can be one of
     <TT
CLASS="literal"
>string</TT
>, <TT
CLASS="literal"
>int</TT
> or <TT
CLASS="literal"
>real</TT
>
     and is defined using the <TT
CLASS="literal"
>type=...</TT
> attribute.
    </P
><P
>&#13;     Optional paramters may be specified using the <TT
CLASS="literal"
>optional='yes'</TT
>
     attribute. Once a parameter has been declared optional all following parameters 
     have to be optional, too. Default values for optional values can be given using
     the <TT
CLASS="literal"
>default=...</TT
> attribute. If no default value is given an
     unset optional parameter defaults to <TT
CLASS="literal"
>NULL</TT
>.
    </P
><P
>&#13;	 For each parameter set of C variables starting with the same name is
     generated that can be used within the functions code snippet.
     The actual variable names and types depend on the parameter type.
    </P
><P
>&#13;     For each parameter a variable by the name of the parameter is created,
     the variable is of type <TT
CLASS="literal"
>char *</TT
> for <TT
CLASS="literal"
>string</TT
>
     parameters, for <TT
CLASS="literal"
>int</TT
>
     it is of type <TT
CLASS="literal"
>long</TT
> and for <TT
CLASS="literal"
>real</TT
> 
     parameters a <TT
CLASS="literal"
>double</TT
> variable is created.
    </P
><P
>&#13;     For <TT
CLASS="literal"
>int</TT
> and <TT
CLASS="literal"
>double</TT
> parameters
     an additional variable <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>name</I
></SPAN
><TT
CLASS="literal"
>_is_null</TT
>
     is created and set to 0 or 1 accordingly. For <TT
CLASS="literal"
>string</TT
>
     parameters no such variable is needed, here the parameter variable is set
     to NULL instead.
    </P
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN138"
>2.3.3. Private data</A
></H3
><P
>&#13;     It is possible to define an associated data structure for a function
     that can store data to be shared across all calls to this function
     during the execution of a statement. This data structure can be used
     to manage allocated buffers across all calls or to store the intermediate
     data while processing an aggregate group.
    </P
><P
>&#13;     The elements of such a data structure are defined using <TT
CLASS="literal"
>&#60;element&#62;</TT
>
     tags within a <TT
CLASS="literal"
>&#60;data&#62;</TT
> section. Each element needs to
     be given a valid C name, type and default value using the <TT
CLASS="literal"
>name=...</TT
>,
     <TT
CLASS="literal"
>type=...</TT
> and <TT
CLASS="literal"
>default=...</TT
> attributes.
    </P
><P
>&#13;     Within the functions code sippets the private data can be accessed
     using the <TT
CLASS="literal"
>data</TT
> pointer that is created and initialized
     in the generated wrapper code.
    </P
><DIV
CLASS="example"
><A
NAME="AEN149"
></A
><P
><B
>Example 2-4. Accessing private data</B
></P
><PRE
CLASS="programlisting"
>&#13;
  &#60;function ...&#62;
   &#60;data&#62; 
    &#60;element name="txt" type="char *" default="NULL"/&#62;
   &#60;/data&#62;
   &#60;init&#62;
    data-&#62;txt = (char *)malloc(...);
   &#60;/init&#62;
   &#60;code&#62;
    strcpy(data-&#62;txt, "...");
   &#60;/code&#62;
   &#60;deinit&#62;
    free(data-&#62;txt);
   &#60;/deinit&#62;
  &#60;/function&#62;

     </PRE
></DIV
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN152"
>2.3.4. Execution of regular functions</A
></H3
><P
>&#13;     A regular function is initialized once for each SQL query it is used in.
     Before the actual execution starts the function is initialized by calling
     the functions <TT
CLASS="literal"
>init</TT
> handle and after execution the functions
     <TT
CLASS="literal"
>deinit</TT
> handle is called to clean up. During the execution
     phase the actual function handle is called for every result row.
    </P
><P
>&#13;     Code for the inid, deinit and execution phase can be added to a function using
     the <TT
CLASS="literal"
>&#60;init&#62;</TT
>, <TT
CLASS="literal"
>&#60;deinit&#62;</TT
> and 
     <TT
CLASS="literal"
>&#60;code&#62;</TT
> tags.
    </P
><P
>&#13;     Code in <TT
CLASS="literal"
>&#60;init&#62;</TT
> is usually used to allocate and initalize
     private data. Parameter count and type checking and allocation of the private
     data structure is handled by the generated code already so the <TT
CLASS="literal"
>&#60;init&#62;</TT
>
     code doesn't have to take care of this anymore.
    </P
><P
>&#13;     The <TT
CLASS="literal"
>&#60;deinit&#62;</TT
> code section usually only has to take care
     of freeing any resources held by elements of the private data structure.
    </P
><P
>&#13;     The actual <TT
CLASS="literal"
>&#60;code&#62;</TT
> section is supposed to perform the
     actual functionality of the function by processing its parameters and returning
     a result value.
    </P
><P
>&#13;     The following macros may be used to return results from the <TT
CLASS="literal"
>&#60;code&#62;</TT
> 
     section:
     <P
></P
><UL
><LI
><P
><TT
CLASS="literal"
>RETURN_STRING(str)</TT
> returns a string, the string length is calculated using <CODE
CLASS="function"
>strlen()</CODE
></P
></LI
><LI
><P
><TT
CLASS="literal"
>RETURN_STRINGL(str, len)</TT
> returns a string of a given length, this saves a call to <CODE
CLASS="function"
>strlen()</CODE
> if the string length is already known and allows to return binary strings that contaion the <TT
CLASS="literal"
>\0</TT
> character</P
></LI
><LI
><P
><TT
CLASS="literal"
>RETURN_INT(val)</TT
> returns an <TT
CLASS="literal"
>int</TT
> value</P
></LI
><LI
><P
><TT
CLASS="literal"
>RETURN_REAL(val)</TT
> returns a <TT
CLASS="literal"
>real</TT
> value</P
></LI
><LI
><P
><TT
CLASS="literal"
>RETURN_NULL()</TT
> returns a <TT
CLASS="literal"
>NULL</TT
> result</P
></LI
></UL
>
    </P
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN192"
>2.3.5. Execution of aggregate functions</A
></H3
><P
>&#13;     The calling sequence of the different handlers of an aggregate function is a little
     more complicated than for a regular function. Both share the <TT
CLASS="literal"
>&#60;init&#62;</TT
>
     and <TT
CLASS="literal"
>&#60;deinit&#62;</TT
> handlers that are called before and after
     executing the actual SQL statement. Two additional handlers <TT
CLASS="literal"
>&#60;start&#62;</TT
>
     and <TT
CLASS="literal"
>&#60;add&#62;</TT
> are called at the beginning of each new group in the
     result and for each row in that group. The <TT
CLASS="literal"
>&#60;result&#62;</TT
> handler is 
     called after the last row of each group has been processed and is supposed to return
     the aggregated result for the group.
    </P
><DIV
CLASS="example"
><A
NAME="AEN200"
></A
><P
><B
>Example 2-5. A simple aggregate function</B
></P
><PRE
CLASS="programlisting"
>&#13;
&#60;function name="sum" type="aggregate" returns="int"&#62;
 &#60;param name="val" type="int"/&#62;
 &#60;data&#62;
  &#60;element name="sum" type="long" default="0"/&#62;
 &#60;/data&#62;
 &#60;start&#62;
  data-&#62;sum = 0;
 &#60;/start&#62;
 &#60;add&#62;
  data-&#62;sum += val;
 &#60;/add&#62;
 &#60;result&#62;
  return data-&#62;sum;
 &#60;/result&#62;
&#60;/function&#62;

     </PRE
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN203"
>2.4. Custom code</A
></H2
><P
>&#13;    Custom code may be added to your extension source files using the
    <TT
CLASS="literal"
>&#60;code&#62;</TT
> tags. The <TT
CLASS="literal"
>role=...</TT
>
    and <TT
CLASS="literal"
>position=...</TT
> tags specify the actual place
    in there generated source files where your code should be
    inserted.
   </P
><P
>&#13;    Possible roles are '<TT
CLASS="literal"
>code</TT
>' (default) for the generated C
    or C++ code file and '<TT
CLASS="literal"
>header</TT
>' header file.
    Possible positions are '<TT
CLASS="literal"
>top</TT
>' and '<TT
CLASS="literal"
>bottom</TT
>'
    (default) for insertion near the beginning or end of the generated file.
   </P
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN214"
>2.5. Dependencies</A
></H2
><P
>&#13;    Libraries, header files and additonal files that an UDF relies on may be
    defined in the <TT
CLASS="literal"
>&#60;deps&#62;</TT
> section. So far only the
    addition of files using the <TT
CLASS="literal"
>&#60;file&#62;</TT
> tag works,
    depending on the file type it is either compiled into the UDF or just
    copied to the UDF directory. Currently C (<TT
CLASS="literal"
>.c</TT
>, C++ 
    (<TT
CLASS="literal"
>.c++</TT
>, <TT
CLASS="literal"
>.cpp</TT
>, <TT
CLASS="literal"
>.cxx</TT
>),
    , lex/flexx (<TT
CLASS="literal"
>.l</TT
>, <TT
CLASS="literal"
>.lex</TT
>, <TT
CLASS="literal"
>.flex</TT
>)
    and yacc/bison (<TT
CLASS="literal"
>.y</TT
>, <TT
CLASS="literal"
>.yacc</TT
>, <TT
CLASS="literal"
>.bison</TT
>)
    source files can be added to be compiled in, files with other extensions
    are just copied.
   </P
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN229"
>2.6. config.m4 fragments</A
></H2
><P
>&#13;    Additional configure checks can be added to the generated config.m4
    file used by Unix/Cygwin builds using the <TT
CLASS="literal"
>&#60;configm4&#62;</TT
> 
    tag. Using the 'position' attribute it is possible to specify whether
    the additional code is to be added at the top or bottom of the 
    config.m4 file.
   </P
><DIV
CLASS="example"
><A
NAME="AEN233"
></A
><P
><B
>Example 2-6. config.m4 additions</B
></P
><PRE
CLASS="screen"
>&#13;
&#60;configm4&#62;
  AC_CHECK_PROG(RE2C, re2c, re2c)
  PHP_SUBST(RE2C)
&#60;/configm4&#62;

    </PRE
></DIV
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN236"
>2.7. Makefile fragments</A
></H2
><P
>&#13;    Makefile rules may be added using the
    <TT
CLASS="literal"
>&#60;makefile&#62;</TT
> for Unix/Cygwin builds.
    Using this it is possible to add dependencies or build rules in
    addition to the default and auto generated rules.
   </P
><DIV
CLASS="example"
><A
NAME="AEN240"
></A
><P
><B
>Example 2-7. Makefile fragments</B
></P
><PRE
CLASS="screen"
>&#13;
&#60;makefile&#62;
$(builddir)/scanner.c: $(srcdir)/scanner.re
  $(RE2C) $(srcdir)/scanner.re &#62; $@
&#60;/makefile&#62;

    </PRE
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="AEN243"
></A
>Chapter 3. XML input parsing</H1
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN245"
>3.1. Includes</A
></H2
><P
>&#13;	The XML parser used by <TT
CLASS="literal"
>CodeGen_PECL</TT
> supports inclusion
    of additional source files using three different ways:
    <P
></P
><UL
><LI
><P
>external entities</P
></LI
><LI
><P
>a subset of XInclude</P
></LI
><LI
><P
>the <TT
CLASS="literal"
>source</TT
> attribute of <TT
CLASS="literal"
>&#60;code&#62;</TT
> tags</P
></LI
></UL
>
   </P
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN258"
>3.1.1. External entities</A
></H3
><P
>&#13;     In SGML and early XML system entites were the only 
     include mechanism availabe. System entities have to
     be defined in the documents DOCTYPE header, later on
     in the document the entity can be used to include 
     the specified file:
    </P
><DIV
CLASS="example"
><A
NAME="AEN261"
></A
><P
><B
>Example 3-1. System Entities</B
></P
><PRE
CLASS="programlisting"
>&#13;
&#60;?xml version="1.0" ?&#62;
&#60;!DOCTYPE extension SYSTEM "../extension.dtd" [
&#60;!ENTITY systemEntity SYSTEM "parsing_1.xml"&#62;
]&#62;
&#60;extension name="foobar"&#62;
...
&#38;systemEntity;
..
&#60;/extension&#62;

     </PRE
></DIV
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN264"
>3.1.2. XInclude</A
></H3
><P
>&#13;     The <TT
CLASS="literal"
>CodeGen</TT
> XML parser supports a simple 
     subset of XInclude, it is possible to include additional
     specification files using the <TT
CLASS="literal"
>href=...</TT
>
     attribute of the <TT
CLASS="literal"
>&#60;include&#62;</TT
> tag:
    </P
><DIV
CLASS="example"
><A
NAME="AEN270"
></A
><P
><B
>Example 3-2. XInclude</B
></P
><PRE
CLASS="programlisting"
>&#13;
  &#60;extension name="foobar" xmlns:xi="http://www.w3.org/2001/XInclude"&#62;
   ...
   &#60;xi:include href="foobar_2.xml"/&#62;
   ...
  &#60;/extension&#62;

     </PRE
></DIV
><P
>&#13;     The <TT
CLASS="literal"
>parse=...</TT
> attirbute is also supported, 
     using <TT
CLASS="literal"
>&#60;include parse='text' href='...'/&#62;</TT
> it is possible to
     include arbitrary data without parsing it as XML.
    </P
><DIV
CLASS="example"
><A
NAME="AEN276"
></A
><P
><B
>Example 3-3. Verbatim XInclude</B
></P
><PRE
CLASS="programlisting"
>&#13;
  &#60;extension name="foobar" xmlns:xi="http://www.w3.org/2001/XInclude"&#62;
   ...
   &#60;description&#62;&#60;xi:include href="README" parse="text"/&#62;&#60;/description&#62;
   ...
  &#60;/extension&#62;

     </PRE
></DIV
><P
>&#13;     Other <TT
CLASS="literal"
>&#60;include&#62;</TT
> features and the <TT
CLASS="literal"
>&#60;fallback&#62;</TT
>
     are not supported yet, and most of them won't make sense in this context anyway.
    </P
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN282"
>3.1.3. <TT
CLASS="literal"
>&#60;code&#62;</TT
> tags</A
></H3
><P
>&#13;     In most places the <TT
CLASS="literal"
>&#60;code&#62;</TT
> tag supports loading of 
     its content using its <TT
CLASS="literal"
>src=...</TT
> attribute:
    </P
><DIV
CLASS="example"
><A
NAME="AEN288"
></A
><P
><B
>Example 3-4. Using <TT
CLASS="literal"
>&#60;code src="..."&#62;</TT
></B
></P
><PRE
CLASS="programlisting"
>&#13;
  &#60;function name="foobar"&#62;
   ...
   &#60;code src="func_foobar.c"/&#62;
  &#60;/function&#62;

     </PRE
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN292"
>3.2. Verbatim text data</A
></H2
><P
>&#13;    C code usually contains quite a few <TT
CLASS="literal"
>&#62;</TT
>, 
    <TT
CLASS="literal"
>&#60;</TT
> and <TT
CLASS="literal"
>&#38;</TT
> characters
    all of which need to be escaped in XML. This can be done by either
    converting them into entities all over the place or by embedding
    the code into CDATA sections:
   </P
><DIV
CLASS="example"
><A
NAME="AEN298"
></A
><P
><B
>Example 3-5. CDATA sections</B
></P
><PRE
CLASS="programlisting"
>&#13;&#60;code&#62;
&#60;![CDATA[
  foo-&#62;bar = 42;
]]&#62;
&#60;/code&#62;
    </PRE
></DIV
><P
>&#13;    Typing <TT
CLASS="literal"
>&#60;![CDATA[</TT
> can become rather annoying
    over time (esp. on a german keyboard), so i introduced the 
    <TT
CLASS="literal"
>&#60;?data</TT
> processing instruction into the
    <TT
CLASS="literal"
>CodeGen</TT
> XML parser as an alternative to CDATA:
   </P
><DIV
CLASS="example"
><A
NAME="AEN305"
></A
><P
><B
>Example 3-6. <TT
CLASS="literal"
>&#60;?data</TT
> processing instruction</B
></P
><PRE
CLASS="programlisting"
>&#13;
&#60;?data
  foo-&#62;bar = 42;
?&#62;

    </PRE
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="AEN309"
></A
>Chapter 4. Usage</H1
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN311"
>4.1. Invocation</A
></H2
><P
>&#13;    The transformation of a XMP specification file into 
    an UDF directory is done by simply calling the
    <TT
CLASS="filename"
>udf-gen</TT
> command with the XML
    filename as argument:
   </P
><PRE
CLASS="programlisting"
>&#13;udf-gen specfile.xml
   </PRE
><P
>&#13;    <TT
CLASS="filename"
>udf-gen</TT
> will refuse to overwrite
    an existing UDF directory (as changes made in there
    may be lost) unless you call it with the <TT
CLASS="literal"
>-f</TT
>
    or <TT
CLASS="literal"
>--force</TT
> option:
   </P
><PRE
CLASS="programlisting"
>&#13;udf-gen -f specfile.xml
   </PRE
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN321"
>4.2. Configuration</A
></H2
><P
>&#13;    You need to configure your UDF for your actual build
    system before compiling it. <TT
CLASS="literal"
>udf-gen</TT
> has
    already created the necessary autotools input files and run
    <TT
CLASS="filename"
>autoconf</TT
> and friends on them so that a
    <TT
CLASS="filename"
>configure</TT
> file is already available.
   </P
><P
>&#13;    You need to run <TT
CLASS="filename"
>configure</TT
> to configure
    your UDF source for your system installation. Most of the time just
    running <TT
CLASS="filename"
>configure</TT
> will be sufficient as 
    appropriate defaults should be picked by the script. 
   </P
><P
>&#13;    If the <TT
CLASS="filename"
>mysql_config</TT
> binary is noth in your
    <TT
CLASS="filename"
>$PATH</TT
> or if you want to build the UDF for
    another MySQL installation than the default one you have to
    speficy the location of <TT
CLASS="filename"
>mylsq_config</TT
>
    when calling configure:
   </P
><PRE
CLASS="programlisting"
>&#13;configure --with-mysql=/path/to/bin/mysql_config
   </PRE
><P
>&#13;    If your 
    extension relies on external libraries installed in non-standard
    places you may want to run <TT
CLASS="filename"
>configure</TT
> with
    the appropriate <TT
CLASS="literal"
>--with-...</TT
> options.
   </P
><P
>&#13;    You can find out about the <TT
CLASS="literal"
>--with-...</TT
> (and other)
    options provided by a <TT
CLASS="literal"
>configure</TT
> script by running:
   </P
><PRE
CLASS="programlisting"
>&#13;configure --help
   </PRE
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN342"
>4.3. Compilation</A
></H2
><P
>&#13;    After configuring your UDF the actual compilation is
    done by the <TT
CLASS="filename"
>make</TT
> command. No further
    parameters are needed at this point:
   </P
><PRE
CLASS="programlisting"
>&#13;make
   </PRE
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN347"
>4.4. Testing</A
></H2
><P
>&#13;    Currently no testing infrastructure is generated,
    it may be provided by a future version though.
    I startet to work on a <TT
CLASS="literal"
>mysql_udf</TT
>
    PECL extension that allows PHP to load UDF libraries 
    and to call the functions provided by it. This might
    be used together with the PHP test infrastructure to
    test UDFs, or maybe test cases for the MySQL test
    infrastructure could be generated instead. All this
    requires further investigation and work being done though.
   </P
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN351"
>4.5. Installation</A
></H2
><P
>&#13;    There is no <TT
CLASS="literal"
>make install</TT
> target yet
    as it is hard to automaticly find the right place to put
    the generated UDF .so libraries. Putting them into
    <TT
CLASS="literal"
>/usr/lib</TT
> is a safe bet but usually you
    don't want to have them there ...
   </P
></DIV
></DIV
></DIV
></BODY
></HTML
>