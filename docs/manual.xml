<?xml version='1.0' encoding='ISO-8859-1' ?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
          "../../phpdoc/dtds/dbxml-4.1.2/docbookx.dtd" [
]>
	 
<book>
 <title><literal>CodeGen_MySQL_UDF</literal> - the MySQL User Defined Functions code generator</title>
  
 <chapter>
  <title>Introduction</title>
  <section>
   <title>What is it?</title>
   <para>
    <literal>CodeGen_MySQL_UDF</literal> is a tool that can automatically create 
    the basic framework for MySQL User Defined Functions (UDF) from a rather 
    simple XML specification file. The actual functionality is provided
    by the script <filename>udf-gen</filename> that is installed by the
    <literal>CodeGen_MySQL_UDF</literal> package.
   </para>
   <para>
    The code generated by <filename>udf-gen</filename> is designed to work
    with MySQL versions 3.23, 4.0, 4.1 and 5.0 without modifications (although
    it is usually necessary to compile it for a specific server version).
   </para>
  </section>

  <section>
   <title>Features</title>
   <para>
    <literal>udf-gen</literal> tries to support as many UDF writing aspects
    as possible. This currently includes code generation for simple and 
    aggregate functions and preparation of <filename>configure</filename>
    and <filename>Makefile</filename> related build files.
   </para>
  </section>

  <section>
   <title>Installation</title>
   <para>
    <literal>CodeGen_MySQL_UDF</literal> is available in PEAR, the
    PHP Extension and Application Repository, on <literal>http://pear.php.net/</literal>.
   </para>

   <section>
    <title>Online installation</title>
    <para>
     Online installation using the PEAR installer is the easiest way 
     to install <literal>CodeGen_MySQL_UDF</literal>, just issue the 
	 following command:
    </para>
    <programlisting>
pear install -o CodeGen_MySQL_UDF
    </programlisting>
    <para>
     The PEAR installer will download and install the package itself
     and all packages that it depends on.
    </para>
   </section>

   <section>
    <title>Installing from package files</title>
    <para>
     When installing from package files downloaded from <literal>pear.php.net</literal>
     you have to resolve dependencies yourself. Currently <literal>CodeGen_PECL</literal>
     depends on two other PEAR packages: <literal>Console_Getopt</literal>, which is part
     of the PEAR base installation, <literal>CodeGen</literal>, the code generator
     base package, and <literal>CodeGen_MySQL</literal>, the base package for MySQL 
     specific code generators. You need to download all three packages for installation.
	 The actual installation is once again performed by the PEAR installer:
    </para>
    <programlisting>
pear install CogeGen-0.9.0.tgz
pear install CogeGen_MySQL-0.9.0.tgz
pear install CogeGen_MySQL-UDF-0.9.0.tgz
    </programlisting>
   </section>

   <section>
    <title>Installing from PEAR CVS</title>
    <para>
     You can also install CodeGen_MySQL_UDF snapshots from PEAR CVS. CVS snapshots may
     include features not yet available in any release package, but the code in
     CVS may not be as well tested as the release packages (or even broken at 
     times). Be warned, your milage may vary. Use the following sequence of 
     commands in your PEAR CVS checkout to install the latest
     <literal>CodeGen_MySQL_UDF</literal> snapshot:
    </para>
    <programlisting>
cd pear
cd CodeGen
cvs update
pear install -f package.xml
cd ..
cd CodeGen_MySQL
cvs update
pear install -f package.xml
cd ..
cd CodeGen_MySQL_UDF
cvs update
pear install -f package.xml
cd ..
    </programlisting>
   </section>
  </section>
  
  <section>
   <title>How to use it</title>
   <para>
    Given that you already have written your XML specs file invocing 
    <filename>udf-gen</filename> is as simple as:
    <screen>udf-gen specfile.xml</screen>
   </para>
   <para>
    <filename>udf-gen</filename> will parse the specs file, create a new
    subdirectory and puts all generated files in there. The generated
    code is ready to be compiled using the usual
    <screen>configure; make</screen>
    sequence.
   </para>
   <para>
    Below you find a hardcopy of <literal>udf-gen --help</literal> output:
   </para>
   <screen>
<![CDATA[
udf-gen 0.9.1dev,Copyright (c) 2003-2005 Hartmut Holzgraefe
Usage:

/usr/local/bin/udf-gen [-hxf] [-d dir] [--version] specfile.xml

  -h|--help          this message
  -x|--experimental  enable experimental features
  -d|--dir           output directory
  -f|--force         overwrite existing files/directories
  -l|--lint          check syntax only, don't create output
  --version          show version info
]]>
   </screen>
  </section>
 </chapter>


 <chapter>
  <title>The XML description</title>
  
  <section>
   <title>Basics</title>
   <para>
    The top level container tag describing an extension is the
    <literal>&lt;extension&gt;</literal> tag. The name of the extension
    is given in the <literal>name=...</literal> attribute. The extension
    name has to be a valid file name as it is used the extensions
    directory name. 
   </para>
   <para>
	You can specify which CodeGen_MySQL_UDF version your specification file
    was build for using the <literal>version=...</literal> attribute.
    The <filename>udf-gen</filename> command will not accept specifications
    written for a newer version of CodeGen_MySQL_UDF than the one installed.
    If the requested version is older then the current one then <filename>udf-gen</filename>
    will try to fall back to the older versions behavior for features
    that have changed in incompatible ways.
   </para>
   <note>
    <para>
     So far no such changes have happened.
    </para>
   </note>
   <para>
    The tags <literal>&lt;summary&gt;</literal> and
    <literal>&lt;description&gt;</literal> should be added at the very top of
    your extensions. The summary should be a short one-line
    description of the extension while the actually description can be
    as detailed as you like.
   </para>
      <example>
    <title>Extension basics</title>
    <programlisting role="xml">
<![CDATA[
<extension name="sample" version="0.9.0">
 <summary>A sample UDF extension</summary>
 <description>
  This is a sample extension specification
  showing how to use CodeGen_MySQL_UDF for
  extension generation.
 </description>
 ...
]]>
    </programlisting>
   </example>
  </section>


  <section>
   <title>Release information</title>
   <para>
    The release information for your UDF extension should include the
    extension authors and maintainers, the version number, state and
    release date, the chosen license and maybe a change log describing
    previous releases. 
   </para>
   <para>
    The <literal>&lt;maintainers&gt;</literal>, <literal>&lt;release&gt;</literal> and
    <literal>&lt;changelog&gt;</literal> tags specifications are identical to  
    those in  the PEAR <literal>package.xml</literal> specification so 
    please refer to the PEAR documentation here.
   </para>
   <example>
    <title>Release information</title>
    <programlisting>
<![CDATA[
...
  <maintainers>
    <maintainer>
      <user>hholzgra</user>
      <name>Hartmut Holzgraefe</name>
      <email>hartmut@php.net</email>
      <role>lead</role>
    </maintainer>
  </maintainers>

  <release>
    <version>1.0</version>
    <date>2002-07-09</date>
    <state>stable</state>
    <notes>
     The sample extension is now stable
    </notes>
  </release>

  <changelog>
    <release>
      <version>0.5</version>
      <date>2002-07-05</date>
      <state>beta</state>
      <notes>First beta version</notes>
    <release>
    <release>
      <version>0.1</version>
      <date>2002-07-01</date>
      <state>alpha</state>
      <notes>First alpha version</notes>
    <release>
  </changelog>
...
]]>
    </programlisting>
   </example>
   <para>
    The <literal>&lt;license&gt;</literal> tag is a little more restrictive as
    its <literal>package.xml</literal> counterpart as it is used to
    decide which license text should actually be written to the
    <literal>LICENSE</literal>. For now you have to specify either
    <literal>GPL</literal>, <literal>LGPL</literal> or
    <literal>BSD</literal>, any other value is taken as
    '<emphasis>unknown</emphasis>'.
   </para>
   <example>
    <title>License</title>
    <programlisting role="xml">
<![CDATA[
...
  <license>GPL</license>
...
]]>
    </programlisting>
   </example>
  </section>

  <section>
   <title>Functions</title>
   <para>
    Two different kinds of functions may be defined using the
    <literal>&lt;function&gt;</literal> tag: <literal>regular</literal> 
    and <literal>aggregate</literal> functions. The function type is 
    determined by the <literal>type=...</literal> attribute and defaults 
    to <literal>regular</literal>. 
   </para>
   <para>
    The function name is defined using the <literal>name=...</literal> 
    attribute and has to be a valid C function name.  
   </para>
   <section>
    <title>Return type</title>
    <para>
     The return type of a function is defined using <literal>returns=...</literal>,
     possible values are <literal>string</literal> (default), <literal>int</literal>,
     and <literal>real</literal>. For a function 
     that may return <literal>NULL</literal> values the <literal>null='yes'</literal>
     attribute has to be set.
    </para>
    <para>
     The <literal>length=...</literal> attribute can be used to define the
     max. length for a <literal>string</literal> result or the number of 
     sigificant digits for <literal>int</literal> and <literal>real</literal>.
     For <literal>real</literal> results the number of significant decimals
     can be defined using the <literal>decimal=...</literal> attribute.
    </para>
   </section>
   <section>
    <title>Parameters</title>
    <para>
     Function parameters are defined using the <literal>&lt;param&gt;</literal>
     tag. The parameter name is defined by the <literal>name=...</literal> attribute
     and has to be a valid C variable name. The parameter type can be one of
     <literal>string</literal>, <literal>int</literal> or <literal>real</literal>
     and is defined using the <literal>type=...</literal> attribute.
    </para>
    <para>
     Optional paramters may be specified using the <literal>optional='yes'</literal>
     attribute. Once a parameter has been declared optional all following parameters 
     have to be optional, too. Default values for optional values can be given using
     the <literal>default=...</literal> attribute. If no default value is given an
     unset optional parameter defaults to <literal>NULL</literal>.
    </para>
    <para>
	 For each parameter set of C variables starting with the same name is
     generated that can be used within the functions code snippet.
     The actual variable names and types depend on the parameter type.
    </para>
    <para>
     For each parameter a variable by the name of the parameter is created,
     the variable is of type <literal>char *</literal> for <literal>string</literal>
     parameters, for <literal>int</literal>
     it is of type <literal>long</literal> and for <literal>real</literal> 
     parameters a <literal>double</literal> variable is created.
    </para>
    <para>
     For <literal>int</literal> and <literal>double</literal> parameters
     an additional variable <emphasis>name</emphasis><literal>_is_null</literal>
     is created and set to 0 or 1 accordingly. For <literal>string</literal>
     parameters no such variable is needed, here the parameter variable is set
     to NULL instead.
    </para>
   </section>
   <section>
    <title>Private data</title>
    <para>
     It is possible to define an associated data structure for a function
     that can store data to be shared across all calls to this function
     during the execution of a statement. This data structure can be used
     to manage allocated buffers across all calls or to store the intermediate
     data while processing an aggregate group.
    </para>
    <para>
     The elements of such a data structure are defined using <literal>&lt;element&gt;</literal>
     tags within a <literal>&lt;data&gt;</literal> section. Each element needs to
     be given a valid C name, type and default value using the <literal>name=...</literal>,
     <literal>type=...</literal> and <literal>default=...</literal> attributes.
    </para>
    <para>
     Within the functions code sippets the private data can be accessed
     using the <literal>data</literal> pointer that is created and initialized
     in the generated wrapper code.
    </para>
    <example>
     <title>Accessing private data</title>
     <programlisting>
<![CDATA[
  <function ...>
   <data> 
    <element name="txt" type="char *" default="NULL"/>
   </data>
   <init>
    data->txt = (char *)malloc(...);
   </init>
   <code>
    strcpy(data->txt, "...");
   </code>
   <deinit>
    free(data->txt);
   </deinit>
  </function>
]]>
     </programlisting>    
    </example>
   </section>
   <section>
    <title>Execution of regular functions</title>
    <para>
     A regular function is initialized once for each SQL query it is used in.
     Before the actual execution starts the function is initialized by calling
     the functions <literal>init</literal> handle and after execution the functions
     <literal>deinit</literal> handle is called to clean up. During the execution
     phase the actual function handle is called for every result row.
    </para>
    <para>
     Code for the inid, deinit and execution phase can be added to a function using
     the <literal>&lt;init&gt;</literal>, <literal>&lt;deinit&gt;</literal> and 
     <literal>&lt;code&gt;</literal> tags.
    </para>
    <para>
     Code in <literal>&lt;init&gt;</literal> is usually used to allocate and initalize
     private data. Parameter count and type checking and allocation of the private
     data structure is handled by the generated code already so the <literal>&lt;init&gt;</literal>
     code doesn't have to take care of this anymore.
    </para>
    <para>
     The <literal>&lt;deinit&gt;</literal> code section usually only has to take care
     of freeing any resources held by elements of the private data structure.
    </para>
    <para>
     The actual <literal>&lt;code&gt;</literal> section is supposed to perform the
     actual functionality of the function by processing its parameters and returning
     a result value.
    </para>
    <para>
     The following macros may be used to return results from the <literal>&lt;code&gt;</literal> 
     section:
     <itemizedlist>
      <listitem><simpara><literal>RETURN_STRING(str)</literal> returns a string, the string length is calculated using <function>strlen()</function></simpara></listitem>
      <listitem><simpara><literal>RETURN_STRINGL(str, len)</literal> returns a string of a given length, this saves a call to <function>strlen()</function> if the string length is already known and allows to return binary strings that contaion the <literal>\0</literal> character</simpara></listitem>
      <listitem><simpara><literal>RETURN_INT(val)</literal> returns an <literal>int</literal> value</simpara></listitem>
      <listitem><simpara><literal>RETURN_REAL(val)</literal> returns a <literal>real</literal> value</simpara></listitem>
      <listitem><simpara><literal>RETURN_NULL()</literal> returns a <literal>NULL</literal> result</simpara></listitem>
     </itemizedlist>
    </para>
   </section>
   <section>
    <title>Execution of aggregate functions</title>
    <para>
     The calling sequence of the different handlers of an aggregate function is a little
     more complicated than for a regular function. Both share the <literal>&lt;init&gt;</literal>
     and <literal>&lt;deinit&gt;</literal> handlers that are called before and after
     executing the actual SQL statement. Two additional handlers <literal>&lt;start&gt;</literal>
     and <literal>&lt;add&gt;</literal> are called at the beginning of each new group in the
     result and for each row in that group. The <literal>&lt;result&gt;</literal> handler is 
     called after the last row of each group has been processed and is supposed to return
     the aggregated result for the group.
    </para>
    <example>
     <title>A simple aggregate function</title>
     <programlisting>
<![CDATA[
<function name="sum" type="aggregate" returns="int">
 <param name="val" type="int"/>
 <data>
  <element name="sum" type="long" default="0"/>
 </data>
 <start>
  data->sum = 0;
 </start>
 <add>
  data->sum += val;
 </add>
 <result>
  return data->sum;
 </result>
</function>
]]>
     </programlisting>
    </example>
   </section>
  </section>

  <section>
   <title>Custom code</title>
   <para>
    Custom code may be added to your extension source files using the
    <literal>&lt;code&gt;</literal> tags. The <literal>role=...</literal>
    and <literal>position=...</literal> tags specify the actual place
    in there generated source files where your code should be
    inserted.
   </para>
   <para>
    Possible roles are '<literal>code</literal>' (default) for the generated C
    or C++ code file and '<literal>header</literal>' header file.
    Possible positions are '<literal>top</literal>' and '<literal>bottom</literal>'
    (default) for insertion near the beginning or end of the generated file.
   </para>
  </section>

  <section>
   <title>Dependencies</title>
   <para>
    Libraries, header files and additonal files that an UDF relies on may be
    defined in the <literal>&lt;deps&gt;</literal> section. So far only the
    addition of files using the <literal>&lt;file&gt;</literal> tag works,
    depending on the file type it is either compiled into the UDF or just
    copied to the UDF directory. Currently C (<literal>.c</literal>, C++ 
    (<literal>.c++</literal>, <literal>.cpp</literal>, <literal>.cxx</literal>),
    , lex/flexx (<literal>.l</literal>, <literal>.lex</literal>, <literal>.flex</literal>)
    and yacc/bison (<literal>.y</literal>, <literal>.yacc</literal>, <literal>.bison</literal>)
    source files can be added to be compiled in, files with other extensions
    are just copied.
   </para>
  </section>

  <section>
   <title>config.m4 fragments</title>
   <para>
    Additional configure checks can be added to the generated config.m4
    file used by Unix/Cygwin builds using the <literal>&lt;configm4&gt;</literal> 
    tag. Using the 'position' attribute it is possible to specify whether
    the additional code is to be added at the top or bottom of the 
    config.m4 file.
   </para>
   <example>
    <title>config.m4 additions</title>
    <screen>
<![CDATA[
<configm4>
  AC_CHECK_PROG(RE2C, re2c, re2c)
  PHP_SUBST(RE2C)
</configm4>
]]>
    </screen>
   </example>
  </section>
    
  <section>
   <title>Makefile fragments</title>
   <para>
    Makefile rules may be added using the
    <literal>&lt;makefile&gt;</literal> for Unix/Cygwin builds.
    Using this it is possible to add dependencies or build rules in
    addition to the default and auto generated rules.
   </para>
   <example>
    <title>Makefile fragments</title>
    <screen>
<![CDATA[
<makefile>
$(builddir)/scanner.c: $(srcdir)/scanner.re
  $(RE2C) $(srcdir)/scanner.re > $@
</makefile>
]]>
    </screen>
   </example>
  </section>

 </chapter>

 <chapter>
  <title>XML input parsing</title>

  <section>
   <title>Includes</title>
   <para>
	The XML parser used by <literal>CodeGen_PECL</literal> supports inclusion
    of additional source files using three different ways:
    <itemizedlist>
     <listitem><simpara>external entities</simpara></listitem>
     <listitem><simpara>a subset of XInclude</simpara></listitem>
     <listitem><simpara>the <literal>source</literal> attribute of <literal>&lt;code&gt;</literal> tags</simpara></listitem>
    </itemizedlist>
   </para>

   <section>
    <title>External entities</title>
    <para>
     In SGML and early XML system entites were the only 
     include mechanism availabe. System entities have to
     be defined in the documents DOCTYPE header, later on
     in the document the entity can be used to include 
     the specified file:
    </para>
    <example>
     <title>System Entities</title>
     <programlisting>
<![CDATA[
<?xml version="1.0" ?>
<!DOCTYPE extension SYSTEM "../extension.dtd" [
<!ENTITY systemEntity SYSTEM "parsing_1.xml">
]>
<extension name="foobar">
...
&systemEntity;
..
</extension>
]]>
     </programlisting>
    </example>
   </section>

   <section>
    <title>XInclude</title>
    <para>
     The <literal>CodeGen</literal> XML parser supports a simple 
     subset of XInclude, it is possible to include additional
     specification files using the <literal>href=...</literal>
     attribute of the <literal>&lt;include&gt;</literal> tag:
    </para>
    <example>
     <title>XInclude</title>
     <programlisting>
<![CDATA[
  <extension name="foobar" xmlns:xi="http://www.w3.org/2001/XInclude">
   ...
   <xi:include href="foobar_2.xml"/>
   ...
  </extension>
]]>
     </programlisting>
    </example>
    <para>
     The <literal>parse=...</literal> attirbute is also supported, 
     using <literal>&lt;include parse='text' href='...'/&gt;</literal> it is possible to
     include arbitrary data without parsing it as XML.
    </para>
    <example>
     <title>Verbatim XInclude</title>
     <programlisting>
<![CDATA[
  <extension name="foobar" xmlns:xi="http://www.w3.org/2001/XInclude">
   ...
   <description><xi:include href="README" parse="text"/></description>
   ...
  </extension>
]]>
     </programlisting>
    </example>
    <para>
     Other <literal>&lt;include&gt;</literal> features and the <literal>&lt;fallback&gt;</literal>
     are not supported yet, and most of them won't make sense in this context anyway.
    </para>
   </section>

   <section>
    <title><literal>&lt;code&gt;</literal> tags</title>
    <para>
     In most places the <literal>&lt;code&gt;</literal> tag supports loading of 
     its content using its <literal>src=...</literal> attribute:
    </para>
    <example>
     <title>Using <literal>&lt;code src="..."&gt;</literal></title>
     <programlisting>
<![CDATA[
  <function name="foobar">
   ...
   <code src="func_foobar.c"/>
  </function>
]]>
     </programlisting>
    </example>
   </section>
  </section>

  <section>
   <title>Verbatim text data</title>
   <para>
    C code usually contains quite a few <literal>&gt;</literal>, 
    <literal>&lt;</literal> and <literal>&amp;</literal> characters
    all of which need to be escaped in XML. This can be done by either
    converting them into entities all over the place or by embedding
    the code into CDATA sections:
   </para>
   <example>
    <title>CDATA sections</title>
    <programlisting>
&lt;code&gt;
&lt;![CDATA[
  foo-&gt;bar = 42;
]]&gt;
&lt;/code&gt;
    </programlisting>
   </example>
   <para>
    Typing <literal>&lt;![CDATA[</literal> can become rather annoying
    over time (esp. on a german keyboard), so i introduced the 
    <literal>&lt;?data</literal> processing instruction into the
    <literal>CodeGen</literal> XML parser as an alternative to CDATA:
   </para>
   <example>
    <title><literal>&lt;?data</literal> processing instruction</title>
    <programlisting>
<![CDATA[
<?data
  foo->bar = 42;
?>
]]>
    </programlisting>
   </example>
  </section>
 </chapter>

 <chapter>
  <title>Usage</title>
  <section>
   <title>Invocation</title>
   <para>
    The transformation of a XMP specification file into 
    an UDF directory is done by simply calling the
    <filename>udf-gen</filename> command with the XML
    filename as argument:
   </para>
   <programlisting>
udf-gen specfile.xml
   </programlisting>
   <para>
    <filename>udf-gen</filename> will refuse to overwrite
    an existing UDF directory (as changes made in there
    may be lost) unless you call it with the <literal>-f</literal>
    or <literal>--force</literal> option:
   </para>
   <programlisting>
udf-gen -f specfile.xml
   </programlisting>
  </section>

  <section>
   <title>Configuration</title>
   <para>
    You need to configure your UDF for your actual build
    system before compiling it. <literal>udf-gen</literal> has
    already created the necessary autotools input files and run
    <filename>autoconf</filename> and friends on them so that a
    <filename>configure</filename> file is already available.
   </para>
   <para>
    You need to run <filename>configure</filename> to configure
    your UDF source for your system installation. Most of the time just
    running <filename>configure</filename> will be sufficient as 
    appropriate defaults should be picked by the script. 
   </para>
   <para>
    If the <filename>mysql_config</filename> binary is noth in your
    <filename>$PATH</filename> or if you want to build the UDF for
    another MySQL installation than the default one you have to
    speficy the location of <filename>mylsq_config</filename>
    when calling configure:
   </para> 
   <programlisting>
configure --with-mysql=/path/to/bin/mysql_config
   </programlisting>
   <para>
    If your 
    extension relies on external libraries installed in non-standard
    places you may want to run <filename>configure</filename> with
    the appropriate <literal>--with-...</literal> options.
   </para>   
   <para>
    You can find out about the <literal>--with-...</literal> (and other)
    options provided by a <literal>configure</literal> script by running:
   </para>
   <programlisting>
configure --help
   </programlisting>
  </section>

  <section>
   <title>Compilation</title>
   <para>
    After configuring your UDF the actual compilation is
    done by the <filename>make</filename> command. No further
    parameters are needed at this point:
   </para>
   <programlisting>
make
   </programlisting>
  </section>

  <section>
   <title>Testing</title>
   <para>
    Currently no testing infrastructure is generated,
    it may be provided by a future version though.
    I startet to work on a <literal>mysql_udf</literal>
    PECL extension that allows PHP to load UDF libraries 
    and to call the functions provided by it. This might
    be used together with the PHP test infrastructure to
    test UDFs, or maybe test cases for the MySQL test
    infrastructure could be generated instead. All this
    requires further investigation and work being done though.
   </para>
  </section>

  <section>
   <title>Installation</title>
   <para>
    There is no <literal>make install</literal> target yet
    as it is hard to automaticly find the right place to put
    the generated UDF .so libraries. Putting them into
    <literal>/usr/lib</literal> is a safe bet but usually you
    don't want to have them there ...
   </para>
  </section>

 </chapter>
</book>